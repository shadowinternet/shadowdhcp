pub mod extensions;
pub mod handlers;
mod reservation;
pub mod worker;

const PREFERRED_LIFETIME: u32 = 3600;
const VALID_LIFETIME: u32 = 7200;

pub use worker::v6_worker;

#[cfg(test)]
mod tests {
    use crate::{
        v6::{extensions::ShadowMessageExtV6, handlers::DhcpV6Response},
        Reservation,
    };
    use advmac::MacAddr6;
    use dhcproto::{
        v6::{
            ClientLinklayerAddress, DhcpOption, DhcpOptions, Message, MessageType, RelayMessage,
            RelayMessageData, IANA, IAPD,
        },
        Decodable,
    };
    use shadow_dhcpv6::{
        config::Config, extractors, leasedb::LeaseDb, reservationdb::ReservationDb, Duid, Option82,
        V4Subnet,
    };
    use std::net::{Ipv4Addr, Ipv6Addr};

    #[test]
    fn reply_test() {
        let mut opts = DhcpOptions::new();
        opts.insert(DhcpOption::RelayMsg(RelayMessageData::Message(
            Message::new(MessageType::Solicit),
        )));

        let reply = RelayMessage {
            msg_type: MessageType::RelayForw,
            hop_count: 0,
            link_addr: Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 8),
            peer_addr: Ipv6Addr::new(1, 2, 3, 4, 5, 6, 7, 9),
            opts,
        };

        println!("{reply:?}");
    }

    #[test]
    fn mikrotik_solicit() {
        let packet_bytes: [u8; 66] = [
            0x01, 0xa4, 0xcf, 0x70, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x00, 0x01, 0x08, 0x55,
            0x31, 0x8f, 0x19, 0x94, 0x00, 0x03, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00,
            0x07, 0x08, 0x00, 0x00, 0x0b, 0x40, 0x00, 0x06, 0x00, 0x02, 0x00, 0x17, 0x00, 0x08,
            0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x19, 0x00, 0x0c, 0x00, 0x00,
            0x00, 0x05, 0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x0b, 0x40,
        ];

        let msg = Message::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type(), MessageType::Solicit));
        assert!(msg.ia_na().is_some());
        assert!(msg.ia_pd().is_some());
        assert_eq!(msg.xid(), [164, 207, 112]);
    }

    #[test]
    fn kea_advertise() {
        let packet_bytes: [u8; 125] = [
            0x02, 0xa4, 0xcf, 0x70, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x00, 0x01, 0x08, 0x55,
            0x31, 0x8f, 0x19, 0x94, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x01, 0x2d, 0xf2,
            0x39, 0xc7, 0xbc, 0x24, 0x11, 0xa7, 0x20, 0x34, 0x00, 0x03, 0x00, 0x28, 0x00, 0x00,
            0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x05, 0x00, 0x18,
            0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x00, 0x19, 0x00, 0x29,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x1a,
            0x00, 0x19, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x38, 0x26, 0x05, 0xcb,
            0x40, 0x80, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];

        let msg = Message::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type(), MessageType::Advertise));
        assert!(msg.ia_na().is_some());
        assert!(msg.ia_pd().is_some());
        assert_eq!(msg.xid(), [164, 207, 112]);
    }

    #[test]
    fn mikrotik_request() {
        let packet_bytes: [u8; 137] = [
            0x03, 0x2a, 0xcb, 0x85, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x00, 0x01, 0x08, 0x55,
            0x31, 0x8f, 0x19, 0x94, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x01, 0x2d, 0xf2,
            0x39, 0xc7, 0xbc, 0x24, 0x11, 0xa7, 0x20, 0x34, 0x00, 0x03, 0x00, 0x28, 0x00, 0x00,
            0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x05, 0x00, 0x18,
            0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x00, 0x06, 0x00, 0x02,
            0x00, 0x17, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x19, 0x00, 0x29, 0x00, 0x00,
            0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x1a, 0x00, 0x19,
            0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x38, 0x26, 0x05, 0xcb, 0x40, 0x80,
            0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let msg = Message::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type(), MessageType::Request));
        assert_eq!(msg.xid(), [42, 203, 133]);
    }

    #[test]
    fn kea_reply() {
        let packet_bytes: [u8; 125] = [
            0x07, 0x2a, 0xcb, 0x85, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x00, 0x01, 0x08, 0x55,
            0x31, 0x8f, 0x19, 0x94, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x01, 0x2d, 0xf2,
            0x39, 0xc7, 0xbc, 0x24, 0x11, 0xa7, 0x20, 0x34, 0x00, 0x03, 0x00, 0x28, 0x00, 0x00,
            0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x05, 0x00, 0x18,
            0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x02, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x00, 0x19, 0x00, 0x29,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x1a,
            0x00, 0x19, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x38, 0x26, 0x05, 0xcb,
            0x40, 0x80, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let msg = Message::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type(), MessageType::Reply));
        assert_eq!(msg.xid(), [42, 203, 133]);
    }

    #[test]
    fn mikrotik_relay_forw_solicit_to_server() {
        let packet_bytes: [u8; 124] = [
            0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x55,
            0x31, 0xff, 0xfe, 0x8f, 0x19, 0x98, 0x00, 0x4f, 0x00, 0x08, 0x00, 0x01, 0x0a, 0x55,
            0x31, 0x8f, 0x19, 0x98, 0x00, 0x12, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x09,
            0x00, 0x42, 0x01, 0x9c, 0x31, 0xb2, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x00, 0x01,
            0x08, 0x55, 0x31, 0x8f, 0x19, 0x94, 0x00, 0x03, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x05,
            0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x0b, 0x40, 0x00, 0x06, 0x00, 0x02, 0x00, 0x17,
            0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x19, 0x00, 0x0c,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x07, 0x08, 0x00, 0x00, 0x0b, 0x40,
        ];

        let msg = RelayMessage::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type, MessageType::RelayForw));
        println!("{msg:?}");
    }

    #[test]
    fn mikrotik_relay_reply_server_advertise_to_client() {
        let packet_bytes: [u8; 171] = [
            0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x55,
            0x31, 0xff, 0xfe, 0x8f, 0x19, 0x98, 0x00, 0x12, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0c,
            0x00, 0x09, 0x00, 0x7d, 0x02, 0x9c, 0x31, 0xb2, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03,
            0x00, 0x01, 0x08, 0x55, 0x31, 0x8f, 0x19, 0x94, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x01,
            0x00, 0x01, 0x2d, 0xf2, 0x39, 0xc7, 0xbc, 0x24, 0x11, 0xa7, 0x20, 0x34, 0x00, 0x03,
            0x00, 0x28, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0,
            0x00, 0x05, 0x00, 0x18, 0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0,
            0x00, 0x19, 0x00, 0x29, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00,
            0x07, 0xd0, 0x00, 0x1a, 0x00, 0x19, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0,
            0x38, 0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
        ];

        let msg = RelayMessage::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type, MessageType::RelayRepl));
        println!("{msg:?}");
    }

    #[test]
    fn mikrotik_relay_forw_request_to_server() {
        let packet_bytes: [u8; 195] = [
            0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x55,
            0x31, 0xff, 0xfe, 0x8f, 0x19, 0x98, 0x00, 0x4f, 0x00, 0x08, 0x00, 0x01, 0x0a, 0x55,
            0x31, 0x8f, 0x19, 0x98, 0x00, 0x12, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x09,
            0x00, 0x89, 0x03, 0xcb, 0x9e, 0x48, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03, 0x00, 0x01,
            0x08, 0x55, 0x31, 0x8f, 0x19, 0x94, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x01, 0x00, 0x01,
            0x2d, 0xf2, 0x39, 0xc7, 0xbc, 0x24, 0x11, 0xa7, 0x20, 0x34, 0x00, 0x03, 0x00, 0x28,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x05,
            0x00, 0x18, 0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x00, 0x06,
            0x00, 0x02, 0x00, 0x17, 0x00, 0x08, 0x00, 0x02, 0x00, 0x00, 0x00, 0x19, 0x00, 0x29,
            0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0, 0x00, 0x1a,
            0x00, 0x19, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0, 0x38, 0x26, 0x05, 0xcb,
            0x40, 0x80, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        ];
        let msg = RelayMessage::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type, MessageType::RelayForw));

        let link_layer_addr = msg
            .opts()
            .iter()
            .find_map(|opt| match opt {
                DhcpOption::ClientLinklayerAddress(ll) => Some(ll),
                _ => None,
            })
            .unwrap();
        println!("{link_layer_addr:?}");
        println!("{msg:?}");
    }

    #[test]
    fn mikrotik_relay_reply_server_reply_to_client() {
        let packet_bytes: [u8; 171] = [
            0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0xfe, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x55,
            0x31, 0xff, 0xfe, 0x8f, 0x19, 0x98, 0x00, 0x12, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0c,
            0x00, 0x09, 0x00, 0x7d, 0x07, 0xcb, 0x9e, 0x48, 0x00, 0x01, 0x00, 0x0a, 0x00, 0x03,
            0x00, 0x01, 0x08, 0x55, 0x31, 0x8f, 0x19, 0x94, 0x00, 0x02, 0x00, 0x0e, 0x00, 0x01,
            0x00, 0x01, 0x2d, 0xf2, 0x39, 0xc7, 0xbc, 0x24, 0x11, 0xa7, 0x20, 0x34, 0x00, 0x03,
            0x00, 0x28, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x07, 0xd0,
            0x00, 0x05, 0x00, 0x18, 0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0,
            0x00, 0x19, 0x00, 0x29, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00,
            0x07, 0xd0, 0x00, 0x1a, 0x00, 0x19, 0x00, 0x00, 0x0b, 0xb8, 0x00, 0x00, 0x0f, 0xa0,
            0x38, 0x26, 0x05, 0xcb, 0x40, 0x80, 0x20, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00,
        ];
        let msg = RelayMessage::from_bytes(&packet_bytes).unwrap();
        assert!(matches!(msg.msg_type, MessageType::RelayRepl));
        println!("{msg:?}");
    }

    fn basic_config() -> Config {
        let subnets_v4 = vec![
            V4Subnet {
                net: "192.168.0.0/24".parse().unwrap(),
                gateway: "192.168.0.1".parse().unwrap(),
            },
            V4Subnet {
                net: "100.110.1.0/24".parse().unwrap(),
                gateway: "100.110.1.1".parse().unwrap(),
            },
        ];
        let dns_v4 = vec![Ipv4Addr::from([8, 8, 8, 8]), Ipv4Addr::from([8, 8, 4, 4])];
        let v4_server_id = Ipv4Addr::from([23, 159, 144, 10]);
        let v6_server_id = Duid::from(vec![0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);

        Config {
            v4_server_id,
            dns_v4,
            subnets_v4,
            v6_server_id,
            option82_extractors: extractors::get_all_extractors().into_values().collect(),
            log_level: tracing::Level::DEBUG,
        }
    }

    #[test]
    fn dynamic_opt82_binding() {
        let json_str = r#"
        [
            {
                "ipv4": "192.168.1.111",
                "ipv6_na": "2001:db8:1:6::1",
                "ipv6_pd": "2001:db8:1:7::/56",
                "option82": {"circuit": "99-11-22-33-44-55", "remote": "eth2:100"}
            },
            {
                "ipv4": "192.168.1.112",
                "ipv6_na": "2001:db8:1:8::1",
                "ipv6_pd": "2001:db8:1:9::/56",
                "duid": "00:11:22:33:44:55:66",
                "option82": {"subscriber": "subscriber:1020"}
            }
        ]
        "#;
        let reservations: Vec<Reservation> = serde_json::from_str(json_str).unwrap();
        let db = ReservationDb::new();
        db.load_reservations(reservations);
        let leases = LeaseDb::new();
        let opt82 = Option82 {
            circuit: Some("99-11-22-33-44-55".into()),
            remote: Some("eth2:100".into()),
            subscriber: None,
        };
        let mac = MacAddr6::new([0x00, 0x11, 0x22, 0x33, 0x44, 0x55]);
        leases.insert_mac_option82_binding(&mac, &opt82);

        let duid = vec![0x00, 0x01];
        let mut msg = Message::new(MessageType::Solicit);
        let msg_opts = msg.opts_mut();
        msg_opts.insert(DhcpOption::ClientId(duid));
        msg_opts.insert(DhcpOption::IANA(IANA {
            id: 1,
            t1: 100,
            t2: 1000,
            opts: DhcpOptions::new(),
        }));
        msg_opts.insert(DhcpOption::IAPD(IAPD {
            id: 1,
            t1: 100,
            t2: 1000,
            opts: DhcpOptions::new(),
        }));

        // pack msg into a relay_msg
        let mut relay_opts = DhcpOptions::new();
        relay_opts.insert(DhcpOption::RelayMsg(RelayMessageData::Message(msg.clone())));
        relay_opts.insert(DhcpOption::ClientLinklayerAddress(ClientLinklayerAddress {
            address_type: 1,
            address: mac.to_array().to_vec(),
        }));

        let relay_msg = RelayMessage {
            msg_type: MessageType::RelayForw,
            hop_count: 0,
            link_addr: Ipv6Addr::new(8, 8, 8, 8, 8, 8, 8, 8),
            peer_addr: Ipv6Addr::new(9, 9, 9, 9, 9, 9, 9, 9),
            opts: relay_opts,
        };

        let resp = match crate::v6::handlers::handle_message(
            &basic_config(),
            &db,
            &leases,
            msg,
            &relay_msg,
        ) {
            DhcpV6Response::Message(resp) => resp.message,
            _ => panic!("Expected message response"),
        };
        assert!(matches!(resp.msg_type(), MessageType::Advertise));

        let reservation = db.by_opt82(&opt82).unwrap();
        assert_eq!(resp.ia_na_address().unwrap(), reservation.ipv6_na);
        assert_eq!(resp.ia_pd_prefix().unwrap(), reservation.ipv6_pd);
    }
}
